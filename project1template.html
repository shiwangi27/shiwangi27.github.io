<!DOCTYPE html>    
<head>
    <meta charset="utf-8">
    <title>fabric.js project template</title>
	
	<!-- Get version 1.5.0 of Fabric.js from CDN -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.5.0/fabric.min.js" ></script> 

	 
<body>
		<!-- canvas tag for Fabric.js to draw into -->
		<canvas id="c" width="4140" height="2200" style="border:2px solid black;" ></canvas>
    
</body>
 
<script>


// within the code below I assume I am drawing into a 1860x990 box
// then I can scale the group to whatever size the final canvas is
// in this case 4140 x 2200 for the wall
// you should pick an appropriate local size and canvas size that are easy for you to work with
var currentBlue = 0.1;
var currentRed = 0.1;
(function() {

  var localHeight = 990;
  var localWidth = 1860;

  var canvas = this.__canvas = new fabric.Canvas('c');


  canvas.backgroundColor = "#5555F5"; // background blue to help find it
  //fabric.Object.prototype.transparentCorners = false;

/*
  canvas.on('mouse:over', function(e) {
    console.log(e.target);
    //canvas.renderAll();
  });

  canvas.on('mouse:out', function(e) {
    console.log(e.target);
    //canvas.renderAll();
  });
*/

var backWall = new fabric.Rect({
  left: 0,
  top: 0,
  fill: 'white',
  stroke: 'black',
  width: 450,
  height: localHeight,
  angle: 0
});
backWall.hasControls = backWall.hasBorders = false;
backWall.lockMovementX = backWall.lockMovementY = true;

var sideWall = new fabric.Rect({
  left: 450,
  top: 0,
  fill: 'white',
  stroke: 'black',
  width: 960,
  height: localHeight,
  angle: 0
});
sideWall.hasControls = sideWall.hasBorders = false;
sideWall.lockMovementX = sideWall.lockMovementY = true;

var frontWall = new fabric.Rect({
  left: 1410,
  top: 0,
  fill: 'white',
  stroke: 'black',
  width: 450,
  height: localHeight,
  angle: 0
});
frontWall.hasControls = frontWall.hasBorders = false;
frontWall.lockMovementX = frontWall.lockMovementY = true;

var bathSpout = new fabric.Rect({
  left: 1635,
  top: 950,
  originX: 'center',
  originY: 'center',
  fill: 'grey',
  stroke: 'black',
  width: 60,
  height: 30,
  angle: 0
});

bathSpout.hasControls = bathSpout.hasBorders = false;
bathSpout.lockMovementX = bathSpout.lockMovementY = true;

// this lets me 'select' it but I cant keep clicking on it more than once

var showerHead = new fabric.Circle({
  radius: 20, fill: 'black', left: 1635, top: 100,   originX: 'center',
  originY: 'center'
});

var tempText = new fabric.Text('default', { left: 1635, top: 500, fontFamily: 'Arial', fontSize: 40, fontWeight: 'italic', originX: 'center',
  originY: 'center',});
tempText.hasControls = tempText.hasBorders = false;
tempText.lockMovementX = tempText.lockMovementY = true;
tempText.selectable = false
tempText.evented = false


var sunshine = new fabric.Circle({
  radius: 30, fill: 'red', left: 1500, top: 500,   originX: 'center',
  originY: 'center'
});

var snowflake = new fabric.Circle({
  radius: 30, fill: 'blue', left: 1770, top: 500,   originX: 'center',
  originY: 'center'
});

//Mat standing or sitting
 

//canvas.bringToFront(mat);

var waterControl = new fabric.Circle({
  left: 1635,
  top: 500,
  originX: 'center',
  originY: 'center',
  fill: 'grey',
  radius: 55
});


sunshine.on('selected', function(e){
  currentRed += 0.1;


  canvas.deactivateAll().renderAll();
  //console.log(currentRed);
  // var f = function(a){ return a; }
  // var a= {0: "red",
  //   f(currentRed): "red",
  //   1: "blue"
  // }
  var d = "blue";
  if(currentRed < 1) {
  var c = 'rgb('+ 255*currentBlue +',0,'+(255 - 255*currentBlue)+')'
} else {
  d = 'rgb('+ 255*currentBlue +',0,'+(255 - 255*currentBlue)+')'
}

  var start = 0;
  var end=1;
  var step = 0.2;
  var j= start;
  var stops= {};
  while (j<end) {
    var color = currentRed > j ? "red" : "blue"
    stops[j] = color;
    j+= step;
  }

  waterControl.setGradient('fill', {
  x1: 0,
  y1: 0,
  x2: waterControl.width ,
  y2: 0,
  colorStops: stops
  });

});

snowflake.on('selected', function(e){
  currentRed -= 0.1;
  //console.log(currentRed);
  // var f = function(a){ return a; }
  // var a= {0: "red",
  //   f(currentRed): "red",
  //   1: "blue"
  // }
  canvas.deactivateAll().renderAll();
  var d = "blue";
  if(currentRed < 1) {
  var c = 'rgb('+ 255*currentBlue +',0,'+(255 - 255*currentBlue)+')'
} else {
  d = 'rgb('+ 255*currentBlue +',0,'+(255 - 255*currentBlue)+')'
}

  var start = 0;
  var end=1;
  var step = 0.2;
  var j= start;
  var stops= {};
  while (j<end) {
    var color = currentRed > j ? "red" : "blue"
    stops[j] = color;
    j+= step;
  }

  waterControl.setGradient('fill', {
  x1: 0,
  y1: 0,
  x2: waterControl.width ,
  y2: 0,
  colorStops: stops
  });
});


waterControl.setGradient('fill', {

  x1: (-waterControl.width / 2),
  y1: 0,
  x2: waterControl.width / 2 -0.1,
  y2: 0,
  colorStops: {
    0: "red",
    1: "blue"
  }
});

var waterTemp = 0; 
 
function updateWaterTemp() { 
if (waterTemp > 0.5) { 
  //waterControl.fill = 'red'; 
  //tempText.text = "hot"; 
  tempText.text = "C";
  tempText.colour = "white"; 
  
  }  
else { 
  //waterControl.fill = 'aqua'; 
  //tempText.text = "cold"; 
  tempText.text = "F";
} 
} 

updateWaterTemp();

waterControl.on('selected', function() {
  //console.log('selected a rectangle');
  waterTemp = 1 - waterTemp;
  updateWaterTemp();
  canvas.deactivateAll(); // deselect everything
});


var mat = new fabric.Rect({
  left: 960,
  top: 800,
  originX: 'center',
  originY: 'center',
  fill: 'red',
  width: 300,
  height: 90
});


//Water in the tub

// fabric.Image.fromURL('Assets/filltub.svg', function(filltubImg) {
//   console.log(filltubImg);
//   // scale image down, and flip it, before adding it onto canvas
//   filltubImg.scale(0.5).setFlipX(true);
//   filltubImg.setLeft(1600);
//   //oImg.opacity(0.5);
//   canvas.add(filltubImg);
// });


// Back wall controls -- Add ons

//Adding Backdrop imagery
var backdrop1 = new fabric.Circle({
  radius: 30,
  fill: 'gray',
  left: 130,
  top: 60
});
var backdrop2 = new fabric.Circle({
  radius: 30,
  fill: 'gray',
  left: 190,
  top: 60
});
var backdrop3 = new fabric.Circle({
  radius: 30,
  fill: 'gray',
  left: 250,
  top: 60
});

//backdrop1.on('selected', function() {

// fabric.Image.fromURL('Assets/moonlight.jpg', function(oImg) {
//   // scale image down, and flip it, before adding it onto canvas
//   oImg.scale(0.5).setFlipX(true);
//   //oImg.opacity(0.5);
//   canvas.add(oImg);
// });

//});

// Adding an analog Clock 




// as a quick test I could have a 'button' that changes colour when I press it

canvas.add(backWall);
canvas.add(sideWall);
canvas.add(frontWall);
canvas.add(showerHead);
canvas.add(bathSpout);
canvas.add(waterControl);
canvas.add(tempText);
canvas.add(sunshine);
canvas.add(snowflake);
canvas.add(mat);
canvas.add(backdrop1);
canvas.add(backdrop2);
canvas.add(backdrop3);
//canvas.add(moonlightInstance);


// code adapted from http://jsfiddle.net/tornado1979/39up3jcm/
function zoomAll(SCALE_FACTOR) {

      var objects = canvas.getObjects();
      for (var i in objects) {
          var scaleX = objects[i].scaleX;
          var scaleY = objects[i].scaleY;
          var left = objects[i].left;
          var top = objects[i].top;

          var tempScaleX = scaleX * SCALE_FACTOR;
          var tempScaleY = scaleY * SCALE_FACTOR;
          var tempLeft = left * SCALE_FACTOR;
          var tempTop = top * SCALE_FACTOR;

          objects[i].scaleX = tempScaleX;
          objects[i].scaleY = tempScaleY;
          objects[i].left = tempLeft;
          objects[i].top = tempTop;

          objects[i].setCoords();
      }
  
     
      canvas.renderAll();
  }


zoomAll(canvas.height / localHeight);

})();




</script>
		
</head>
  
</html>